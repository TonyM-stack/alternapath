
CREATE EXTENSION IF NOT EXISTS citext;

-- === USERS ===
CREATE TABLE IF NOT EXISTS users (
  user_id        INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username       CITEXT UNIQUE NOT NULL,
  email          CITEXT UNIQUE NOT NULL,
  password_hash  TEXT NOT NULL,
  first_name     TEXT,
  last_name      TEXT,
  created_at     TIMESTAMP NOT NULL DEFAULT now(),
  updated_at     TIMESTAMP NOT NULL DEFAULT now()
);

-- === AILMENTS ===
CREATE TABLE IF NOT EXISTS ailments (
  ailment_id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ailment_slug   TEXT UNIQUE NOT NULL,
  ailment_title  TEXT NOT NULL,
  link           TEXT,
  created_at     TIMESTAMP NOT NULL DEFAULT now(),
  updated_at     TIMESTAMP NOT NULL DEFAULT now()
);

-- === REMEDIES ===
CREATE TABLE IF NOT EXISTS remedies (
  remedy_id            INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  remedy_name          TEXT NOT NULL,
  description          TEXT,
  potency              TEXT,
  dosage_instructions  TEXT,
  created_at           TIMESTAMP NOT NULL DEFAULT now(),
  updated_at           TIMESTAMP NOT NULL DEFAULT now()
);

-- === Join Table: AILMENT â†” REMEDY (many-to-many with extra fields) ===
CREATE TABLE IF NOT EXISTS ailment_remedies (
  ailment_remedy_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ailment_id          INT NOT NULL,
  remedy_id           INT NOT NULL,
  symptom_description TEXT NOT NULL,
  sort_order          INT DEFAULT 0,
  created_at          TIMESTAMP NOT NULL DEFAULT now(),
  CONSTRAINT fk_ar_ailment FOREIGN KEY (ailment_id)
    REFERENCES ailments(ailment_id) ON DELETE CASCADE,
  CONSTRAINT fk_ar_remedy FOREIGN KEY (remedy_id)
    REFERENCES remedies(remedy_id) ON DELETE CASCADE,
  CONSTRAINT unique_ailment_remedy UNIQUE (ailment_id, remedy_id, symptom_description)
);

-- === USER FAVORITES ===
CREATE TABLE IF NOT EXISTS user_favorites (
  favorite_id  INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id      INT NOT NULL,
  ailment_id   INT,
  remedy_id    INT,
  created_at   TIMESTAMP NOT NULL DEFAULT now(),
  CONSTRAINT fk_fav_user    FOREIGN KEY (user_id)    REFERENCES users(user_id)    ON DELETE CASCADE,
  CONSTRAINT fk_fav_ailment FOREIGN KEY (ailment_id) REFERENCES ailments(ailment_id) ON DELETE CASCADE,
  CONSTRAINT fk_fav_remedy  FOREIGN KEY (remedy_id)  REFERENCES remedies(remedy_id)  ON DELETE CASCADE,
  -- ensure at least one target is set (allow both if you want)
  CONSTRAINT chk_fav_target CHECK (ailment_id IS NOT NULL OR remedy_id IS NOT NULL)
);

-- === Indexes ===
CREATE INDEX IF NOT EXISTS idx_ailments_slug     ON ailments (ailment_slug);
CREATE INDEX IF NOT EXISTS idx_ailments_title    ON ailments (ailment_title);
CREATE INDEX IF NOT EXISTS idx_remedies_name     ON remedies (remedy_name);
CREATE INDEX IF NOT EXISTS idx_ar_ailment        ON ailment_remedies (ailment_id);
CREATE INDEX IF NOT EXISTS idx_ar_remedy         ON ailment_remedies (remedy_id);
CREATE INDEX IF NOT EXISTS idx_fav_user          ON user_favorites (user_id);
CREATE INDEX IF NOT EXISTS idx_fav_ailment       ON user_favorites (ailment_id);
CREATE INDEX IF NOT EXISTS idx_fav_remedy        ON user_favorites (remedy_id);

-- === updated_at triggers ===
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_updated_at') THEN
    CREATE TRIGGER trg_users_updated_at
      BEFORE UPDATE ON users
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_ailments_updated_at') THEN
    CREATE TRIGGER trg_ailments_updated_at
      BEFORE UPDATE ON ailments
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_remedies_updated_at') THEN
    CREATE TRIGGER trg_remedies_updated_at
      BEFORE UPDATE ON remedies
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;
END $$;
